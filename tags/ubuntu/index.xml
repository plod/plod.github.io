<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ubuntu on plod.tv</title>
    <link>https://plod.tv/tags/ubuntu/index.xml</link>
    <description>Recent content in Ubuntu on plod.tv</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <atom:link href="https://plod.tv/tags/ubuntu/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Multiple site free ssl with http2 nginx</title>
      <link>https://plod.tv/post/multiple-site-free-ssl-http2-nginx/</link>
      <pubDate>Fri, 19 Feb 2016 14:40:27 +0000</pubDate>
      
      <guid>https://plod.tv/post/multiple-site-free-ssl-http2-nginx/</guid>
      <description>

&lt;p&gt;There still exists this myth that you require a single IP address per vhost for an ssl certificate. It was perpetuated because the encryption handshake used to happen before the resource required could be ascertained, thanks to some pretty serious security vulnerabilites SSL itself is pretty much a dead duck and the modern TLS has superceded it. One of the great things about TLS is SNI:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Server Name Indication (SNI) is an extension to the TLS computer networking protocol[1] by which a client indicates which hostname it is attempting to connect to at the start of the handshaking process. This allows a server to present multiple certificates on the same IP address and TCP port number and hence allows multiple secure (HTTPS) websites (or any other Service over TLS) to be served off the same IP address without requiring all those sites to use the same certificate. It is the conceptual equivalent to HTTP/1.1 name-based virtual hosting, but for HTTPS. &lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;more here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although in this example we are going to use one certificate across multiple vhosts.&lt;/p&gt;

&lt;h2 id=&#34;but-secure-websites-require-buying-a-certificate-which-is-expensive&#34;&gt;But secure websites require buying a certificate which is expensive!&lt;/h2&gt;

&lt;p&gt;Haven&amp;rsquo;t you heard of &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; yet?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let’s Encrypt is a new Certificate Authority:
It’s free, automated, and open.
In Public Beta&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;so-what-s-http2&#34;&gt;So what&amp;rsquo;s http2?&lt;/h2&gt;

&lt;p&gt;You may have already heard of the magic google did with SPDY well that and even more features are being rolled into HTTP2, and you can have your website future proofed and supporting these features right now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP/2 (originally named HTTP/2.0) is the second major version of the HTTP network protocol used by the World Wide Web. It is based on SPDY. HTTP/2 was developed by the Hypertext Transfer Protocol working group (httpbis, where bis means &amp;ldquo;repeat&amp;rdquo; or &amp;ldquo;twice&amp;rdquo;) of the Internet Engineering Task Force. &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP/2&#34;&gt;More Here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;let-s-do-this&#34;&gt;Let&amp;rsquo;s do this!&lt;/h2&gt;

&lt;p&gt;Okay for the purpose of this post, I will show you how to get sorted with ubuntu (15.04). It is relatively straight forward to do the same for other distrubutions following the links provided. But if you are having difficulty please write your questions in the comments below.&lt;/p&gt;

&lt;p&gt;At the time of writing the stable version in the nginx repositories is not a high enough version for http2 (It became available in &lt;a href=&#34;https://www.nginx.com/blog/nginx-1-9-5/&#34;&gt;version 1.9.5&lt;/a&gt;), so you need to add the mainline repositories to your apt (though depending on when you are reading this that could have changed).&lt;/p&gt;

&lt;p&gt;Instructions for adding the repositories can be found &lt;a href=&#34;http://nginx.org/en/linux_packages.html#mainline&#34;&gt;here&lt;/a&gt;. But I&amp;rsquo;ll include them for the sake of brevity.&lt;/p&gt;


wget -q http://nginx.org/keys/nginx_signing.key -O- | sudo apt-key add -


&lt;p&gt;Then add the following to /etc/apt/sources.list.d/nginx.list:&lt;/p&gt;


deb http://nginx.org/packages/mainline/ubuntu/ codename nginx
deb-src http://nginx.org/packages/mainline/ubuntu/ codename nginx


&lt;p&gt;Where codename should be your release codename, wily in my case. Then to install:&lt;/p&gt;


apt-get update
apt-get install nginx


&lt;p&gt;Okay after doing its thing you should now have nginx at a new enough version for http2.&lt;/p&gt;

&lt;h1 id=&#34;now-for-a-free-signed-cert&#34;&gt;Now for a free signed cert.&lt;/h1&gt;

&lt;p&gt;I followed &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04&#34;&gt;this&lt;/a&gt; tutorial from digital ocean (great tutorials) to get the certificate up and running with the following extra bits.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make sure you have all the vhosts you want to host with nginx (you won&amp;rsquo;t create a certificate for every domain there really is no need, you can reuse the one)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When you are creating seperate vhost configs in nginx (doing this is a bit beyond the scope of this article but if you need help comment below), add the following directive to the vhost (to point the letsencrypt requests back to the default sites):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


 location /.well-known/ {
        alias /var/www/html/.well-known/;
        allow all;
    }


&lt;p&gt;Then to enable http2 for each of the vhosts add the keyword at the top of your server block where your listen is:&lt;/p&gt;


    listen 443 ssl http2;


&lt;h1 id=&#34;welcome-to-the-future&#34;&gt;Welcome to the future!&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Setting up a hugo based website on ubuntu then auto deploy using gogs&#39; webhooks</title>
      <link>https://plod.tv/post/Setting-up-hugo-git-auto-deploy/</link>
      <pubDate>Thu, 18 Feb 2016 12:29:13 +0000</pubDate>
      
      <guid>https://plod.tv/post/Setting-up-hugo-git-auto-deploy/</guid>
      <description>

&lt;h2 id=&#34;what-is-hugo&#34;&gt;What is Hugo?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Hugo is a static HTML and CSS website generator written in Go. It is optimized for speed, easy use and configurability. Hugo takes a directory with content and templates and renders them into a full HTML website.&lt;/p&gt;

&lt;p&gt;Hugo relies on Markdown files with front matter for meta data. And you can run Hugo from any directory. This works well for shared hosts and other systems where you don’t have a privileged account.&lt;/p&gt;

&lt;p&gt;Hugo renders a typical website of moderate size in a fraction of a second. A good rule of thumb is that each piece of content renders in around 1 millisecond.&lt;/p&gt;

&lt;p&gt;Hugo is designed to work well for any kind of website including blogs, tumbles and docs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;what-is-gogs&#34;&gt;What is Gogs?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The goal of this project is to make the easiest, fastest, and most painless way of setting up a self-hosted Git service. With Go, this can be done with an independent binary distribution across ALL platforms that Go supports, including Linux, Mac OS X, Windows and ARM.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://gogs.io/&#34;&gt;https://gogs.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is a great self hosting github/gitlabs sort of project but coded in go.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I started by following &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-hugo-a-static-site-generator-on-ubuntu-14-04&#34;&gt;this digital ocean tutorial&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t want to use a package, my preference was to compile from &lt;a href=&#34;https://gohugo.io/overview/installing/&#34;&gt;source&lt;/a&gt;. However I got the following error while trying that:

go: missing Mercurial command. See https://golang.org/s/gogetcmd
package bitbucket.org/pkg/inflect: exec: &#34;hg&#34;: executable file not found in $PATH

Thanks to &lt;a href=&#34;http://kaiq.me/2015/12/23/go/go-get-tools/&#34;&gt;this&lt;/a&gt; and google translate I realised Mercurial was a dependancy.&lt;/p&gt;

&lt;p&gt;so

sudo apt-get install mercurial

and then&lt;/p&gt;


go get -u -v github.com/spf13/hugo


&lt;p&gt;got me cooking!&lt;/p&gt;

&lt;p&gt;In the DO tutorial it says to run&lt;/p&gt;


sudo hugo genautocomplete


&lt;p&gt;this seems to be factored out to&lt;/p&gt;


sudo hugo gen autocomplete


&lt;p&gt;but because I compiled from source hugo isn&amp;rsquo;t in sudo environment path so&lt;/p&gt;


sudo ~/go-workspace/bin/hugo gen autocomplete


&lt;p&gt;[~/go-workspace is my $GOPATH so change to yours]&lt;/p&gt;

&lt;p&gt;While cloning the themes I decided hugo-themes was a better name for the directory in my home dir (themes could be anything while browsing later), of course this meant later, my symlink would need to look like:&lt;/p&gt;


 ln -s ../hugo-themes/ themes


&lt;p&gt;It seems that some other switches are different from the DO tutorial (-themes= in git cloned version is -t )&lt;/p&gt;

&lt;h1 id=&#34;auto-deploy&#34;&gt;Auto deploy&lt;/h1&gt;

&lt;p&gt;This is based on the digital ocean tutorial &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-deploy-a-hugo-site-to-production-with-git-hooks-on-ubuntu-14-04&#34;&gt;here&lt;/a&gt; the difference however was, is I use gogs, the server itself has no firewall access to my gogs server. I decided to solve this problem using the tutorial/gogs&amp;rsquo; web hooks/and a little php (that I&amp;rsquo;m sure I&amp;rsquo;ll refactor as go at some stage)&lt;/p&gt;

&lt;p&gt;First of all lets set up the gogs web hook:&lt;/p&gt;

&lt;p&gt;Inside the repository in question click on the settings link on the right hand side&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://plod.tv/img/post-img/gogs-settings.png&#34; alt=&#34;Gogs Settings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then click on the Webhooks link on the left hand side&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://plod.tv/img/post-img/gogs-webhooks.png&#34; alt=&#34;Gogs Webhooks&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally enter a url the gogs server can connect to and that you can write php on (make a note of the Secret that you use)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://plod.tv/img/post-img/gogs-webhook.png&#34; alt=&#34;Gogs Webhook&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now the php that runs at the URL you entered above should look a little something like this.&lt;/p&gt;


&lt;?php
//gogs secret for web hook
$secret   = &#34;&#34;;

//keyword you are looking for in commit message to decide if to desploy
$deployCommitKeyword = &#34;[deploy] &#34;;
$json = (array) json_decode(file_get_contents(&#39;php://input&#39;));

if(array_key_exists(&#39;secret&#39;, $json)&amp;&amp;($json[&#39;secret&#39;]==$secret)){
    echo &#39;secret matched&#39;;
    if(array_key_exists(&#39;commits&#39;, $json)){
        for($i=0, $j=count($json[&#39;commits&#39;]); $i&lt;$j; $i++){
            $json[&#39;commits&#39;][$i] = (array) $json[&#39;commits&#39;][$i];
            if(array_key_exists(&#39;message&#39;, $json[&#39;commits&#39;][$i])&amp;&amp;(strstr($json[&#39;commits&#39;][$i][&#39;message&#39;], $deployCommitKeyword))){
                do_deploy();
                break;
            }
    }
}

function do_deploy(){
    $GIT_REPO           = &#34;$HOME/my-website.git&#34;;
    $WORKING_DIRECTORY  = &#34;$HOME/my-website-working&#34;;
    $REMOTE_BACKUP_HTML = &#34;backup_html/&#34;;
    $REMOTE_PUBLIC_HTML = &#34;public_html/&#34;;
    $MY_SERVER_IP       = &#34;server_domain_or_IP
1&#34;;
 
    if(!is_dir($WORKING_DIRECTORY)){
        $command = &#34;git clone $GIT_REPO $WORKING_DIRECTORY&#34;;
        echo `$command`;
    }else{
        $command = &#34;cd $WORKING_DIRECTORY; git pull&#34;;
        echo `$command`;
    }
    $command = &#34;cd $WORKING_DIRECTORY; /path/to/hugo&#34;;
    echo `$command`;
    //lets rsync a copy of the working directory to backup
    $command = &#34;ssh $MY_SERVER_IP rsync -r $REMOTE_PUBLIC_HTML $REMOTE_BACKUP_HTML&#34;;
    echo `$command`;
    $command = &#34;rsync -r $WORKING_DIRECTORY/public/ $MY_SERVER_IP:$REMOTE_PUBLIC_HTML&#34;;
    echo `$command`;
}


&lt;p&gt;&lt;em&gt;*update&lt;/em&gt; I noticed that syntax hilighting was going missing on this post (turned out that pygmatize was not in path of the php process) (php runs as my user account) so I fixed this by changing&lt;/p&gt;


$command = &#34;cd $WORKING_DIRECTORY; /path/to/hugo&#34;;
echo `$command`;


&lt;p&gt;to&lt;/p&gt;


$command = &#34;cd $WORKING_DIRECTORY; export PATH=\&#34;What my $PATH is at tty\&#34; hugo&#34;;
echo `$command`;


&lt;p&gt;This felt a little dirty but after many attempts at a more elegent solution, I have stayed with this for the time being.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>